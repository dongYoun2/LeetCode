[Problem](https://leetcode.com/problems/n-queens-ii/description/)


## Backtracking

This solution is optimized version of the `01_27_2026.py` solution. The main trick is to use additional diagonal and anti-diagonal tracking arrays so that we can check if a cell is valid in $O(1)$ time (unlike using the set operation).

- [Submission](https://leetcode.com/problems/n-queens-ii/submissions/1899140872/)—Runtime: 3 ms (Beats 94.13%), Memory: 19.44 MB (Beats 20.84%)
- TC: backtracking is commonly bounded by $O(n!)$; much faster in practice due to the pruning ($n$: size of the board)
- SC: $O(n)$ (recursion depth + arrays)

The code is generated by ChatGPT.


```python
class Solution:
    def totalNQueens(self, n: int) -> int:
        # cols: which columns already have a queen
        # diag1: main diagonals (r - c) shifted by + (n-1) to make index >= 0
        # diag2: anti-diagonals (r + c)
        cols = [False] * n
        diag1 = [False] * (2 * n - 1)   # indices: (r - c + n - 1) in [0, 2n-2]
        diag2 = [False] * (2 * n - 1)   # indices: (r + c) in [0, 2n-2]

        ans = 0

        def dfs(r: int) -> None:
            """
            We place exactly 1 queen in each row.
            State (used so far):
              - cols[c]  : is column c already taken?
              - diag1[r-c+n-1] : is main diagonal taken?
              - diag2[r+c]     : is anti diagonal taken?
            """
            nonlocal ans
            if r == n:          # placed queens in rows 0..n-1
                ans += 1
                return

            for c in range(n):
                d1 = r - c + (n - 1)    # main diagonal index
                d2 = r + c              # anti diagonal index

                # Check (O(1)) if placing at (r,c) is valid
                if cols[c] or diag1[d1] or diag2[d2]:
                    continue

                # ---- place queen: mark those 3 lines as used ----
                cols[c] = True
                diag1[d1] = True
                diag2[d2] = True

                # Move to next row (shape of state doesn't change: just booleans flip)
                dfs(r + 1)

                # ---- remove queen (backtrack) ----
                cols[c] = False
                diag1[d1] = False
                diag2[d2] = False

        dfs(0)
        return ans

```

----

### Thought Process and Intuition behind Diagonal Indexing

#### 1) Start from the board (concrete thinking)

We index the chessboard using **row, column** coordinates:

- Rows: `0 ... n-1`
- Columns: `0 ... n-1`

A queen placed at position `(r, c)` attacks:
- the entire **column** `c`
- the two **diagonal directions**

So the problem becomes:

> How can we uniquely identify a diagonal using numbers derived from `(r, c)`?

If we can map each diagonal to a unique index, we can check conflicts in **O(1)** time.


#### 2) Look at one diagonal and write down coordinates

**Main diagonal (↘ direction)**

Cells on the same ↘ diagonal: (0,0) (1,1) (2,2) (3,3)
Compute `r - c`:

| Cell  | r - c |
|-------|-------|
| (0,0) |   0   |
| (1,1) |   0   |
| (2,2) |   0   |
| (3,3) |   0   |

Another ↘ diagonal: (0,1) (1,2) (2,3)
| Cell  | r - c |
|-------|-------|
| (0,1) |  -1   |
| (1,2) |  -1   |
| (2,3) |  -1   |

**Observation:**  
All cells on the same ↘ diagonal share the same value of `r - c`, which is a constant. So we can uniquely identify each ↘ diagonal using `r - c`. Because `r - c` ranges from `-(n-1)` to `+(n-1)`, we shift it to be non-negative: `diag1_index = r - c + (n - 1)`


**Anti-diagonal (↙ direction)** is similar, but with a different constant (`r + c`) since it's symmetric to the main diagonal.

#### Why this works (math intuition)
A diagonal is defined by a constant slope:
- ↘︎ diagonals: slope = 1 → equation r - c = constant
- ↙︎ diagonals: slope = -1 → equation r + c = constant


