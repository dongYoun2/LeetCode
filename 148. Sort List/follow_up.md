[Problem Link](https://leetcode.com/problems/sort-list/)

## Iteartive Merge Sort

The code below was generated by ChatGPT based on a prompt where I provided my recursive merge sort implementation and asked it to use the slow and fast pointer technique to find the middle node.

- [Submission](https://leetcode.com/problems/sort-list/submissions/1648452256/) (Runtime: 283 ms, Memory: 32.95 MB)
- TC: $O(n \log n)$, where $n$ is the number of nodes in the linked list.
- SC: $O(1)$, no recursion stack needed.
<br>

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def merge_sorted_list(head1, head2):
            ptr = dummy = ListNode()

            curr1 = head1
            curr2 = head2

            while curr1 is not None and curr2 is not None:
                if curr1.val < curr2.val:
                    ptr.next = curr1
                    curr1 = curr1.next
                else:
                    ptr.next = curr2
                    curr2 = curr2.next

                ptr = ptr.next

            remaining = curr1 or curr2
            ptr.next = remaining  # we don't need a loop here

            return dummy.next


        def merge():
            # Count length of the list (n)
            n = 0
            node = head
            while node:
                n += 1
                node = node.next

            dummy = ListNode(0, head)
            size = 1

            while size < n:
                prev = dummy
                curr = dummy.next

                while curr:
                    # Split the first sublist
                    head1 = curr
                    i = 1
                    while i < size and curr and curr.next:
                        curr = curr.next
                        i += 1

                    # Split the second sublist
                    head2 = curr.next if curr else None
                    if curr:
                        curr.next = None  # cut first sublist

                    curr = head2
                    i = 1
                    while i < size and curr and curr.next:
                        curr = curr.next
                        i += 1

                    next_sublist = curr.next if curr else None
                    if curr:
                        curr.next = None  # cut second sublist

                    # Merge the two sublists
                    merged = merge_sorted_list(head1, head2)
                    prev.next = merged

                    # Move prev to the end of merged list
                    while prev.next:
                        prev = prev.next

                    # Move to the next pair of sublists
                    curr = next_sublist

                size *= 2

            return dummy.next


        return merge()

```