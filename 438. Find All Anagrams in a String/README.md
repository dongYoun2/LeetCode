[Problem](https://leetcode.com/problems/find-all-anagrams-in-a-string/)


The code below is generated by ChatGPT. Instead of using the `Counter` class, it uses frequency arrays for 26 lowercase letters. Comparing two fixed-size lists is more efficient than comparing `Counter` objects. Also, once the window size grows to the length of `p`, we maintain the window size by removing the leftmost character.

- [Submission](https://leetcode.com/problems/find-all-anagrams-in-a-string/submissions/1932213389/)â€”Runtime: 27 ms (beats 90.52%), Memory: 20.02 MB (beats 15.82%)
- TC: $O(n)$, where $n$ is the length of $s$
- SC: $O(1)$


```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        n, m = len(s), len(p)
        if m > n:
            return []

        res = []
        
        # Step 1: frequency arrays for 26 lowercase letters
        p_count = [0] * 26
        window = [0] * 26
        
        # Step 2: build p_count
        for c in p:
            p_count[ord(c) - ord('a')] += 1
        
        # Step 3: sliding window over s
        left = 0
        for right in range(n):
            # add right character
            window[ord(s[right]) - ord('a')] += 1
            
            # keep window size == m
            if right - left + 1 > m:
                window[ord(s[left]) - ord('a')] -= 1
                left += 1
            
            # compare counts
            if window == p_count:
                res.append(left)
        
        return res

```


Below is a code directly comparing two `Counter` objects. This is also a valid solution though the runtime is slower than the previous code.

- [Submission](https://leetcode.com/problems/find-all-anagrams-in-a-string/submissions/1932211724/)â€”Runtime: 158 ms (beats 32.83%), Memory: 19.98 MB (beats 38.49%)
- Time and space complexities are same as the previous code.

```python
from collections import Counter

class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        p_cntr = Counter(p)
        s_cntr = Counter(s[:len(p) - 1])

        ans = []

        for i in range(len(p) - 1, len(s)):
            s_cntr[s[i]] += 1

            start_i = i - len(p) + 1
            if s_cntr == p_cntr:    # O(1) b/c at most 26 English chars
                ans.append(start_i)
            
            s_cntr[s[start_i]] -= 1

        return ans

```